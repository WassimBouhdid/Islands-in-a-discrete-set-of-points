<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="optIslands" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link href="index.css" rel="stylesheet" />
    <title>OptIslands</title>
  </head>
  <body>
    <div id="content">
        <h1>Optimal islands</h1>
        <div id="navBar">
            <div id="introSelect" class="navTab selected" section="introduction">introduction</div>
            <div id="preprocessingSelect" class="navTab" section="preprocessing">preprocessing</div>
            <div id="definitionsSelect" class="navTab" section="definitions">definitions</div>
            <div id="mainSelect" class="navTab" section="mainAlgorithm">main algorithm</div>
            <div id="animationSelect" class="navTab" section="animation">animation</div>
            <div id="multiplicitySelect" class="navTab" section="multiplicity">multiplicity</div>
            <div id="generalization" class="navTab" section="generalization">generalization</div>
            <div id="references" class="navTab" section="references">references</div>
        </div>
        <div id="introduction" class="sectionDiv currentSection">
            <h2>Context</h2>
            <div class="section">Given a set of 2D points S, an island I is a subset of S such that I &#x2229 S = CH(I). In other words, a subset of S is an island iff it contains all points of S that are within its own convex hull.</div>
            <h2>Objective</h2>
            <div class="section">We are given a set S of n points, whose coordinates are stored in an array in arbitrary order. Those points are each assigned a color : blue or red. Our mission here is to find the largest monochromatic island : an island containing a maximal number of points that are all the same color. WLOG, we will present an algorithm to find the largest blue island in S ; it can be run again after flipping colors to obtain the largest island of any color. This algorithm runs it time O(n^3) and space O(n^2).</div>
        </div>
        <div id="preprocessing" class="sectionDiv">
            <div>Before jumping to the core ideas of the algorithm, let us build auxiliary structures that will be helpful.
                <h2>Radial orderings</h2>
                Most of the following steps rely strongly on radial orderings, and having to perform radial sort all over again each time we need one would compromise satisfaction of O(n^3) requirement. This is why we first build a data structure that allows to retrieve at most in linear time, for any reference point of S, some radial ordering of other points.
                <h3>Data structure</h3>
                Most of the following steps rely strongly on radial orderings, and having to perform radial sort all over again each time we need one would compromise satisfaction of O(n^3) requirement. This is why we first build a data structure that allows to retrieve at most in linear time, for any reference point of S, some radial ordering of other points.
                Concretely, this structure consists of a matrix R of size n x (n - 1) s.t. line i of R a sequence of points S \ {i} coming in counter-clockwise order w.r.t. i, starting from an arbitrary point. There is one small caveat when it comes to generating this sequence : radial sort is based on comparison with orientation determinant, which is not a transitive relationship for vectors of arbitrary directions. In order to compute a line of R, the set S \ {i} must first be partitioned into two subsets, each on either side of some line that goes through the reference point. Those two parts are then sorted individually and concatenated together. The whole construction process takes O(n^2logn) time, which meets the overall O(n^3) requirement.
                <h3>Half-cut</h3>
                It is important to note that those are circular sequences that start with an arbitrary point, and are not in radial order strictly speaking. In what follows, we will most often need to extract a sequence in strict radial order, for a given reference point, that contains only points on the left of a certain.
                To this end, we introduce an operation called "half cut", which returns this sequence for a given reference point, its "counte-clockwise ordering" taken in R, and a "cut vector".
                <h2>Number of points inside a triangle</h2>
                As we , the algorithm exploit p-compatibility. 
                <par>Another crucial information that we will need to retrieve quickly is, for any triangle formed by 3 distinct points in S, the number of points contained in this triangle. Overmars et. al. propose a method to build in O(n^2) space and time a table that allows to retrieve this information in constant time afterward [ref]. It consists of a table T of size n x (n - 1) s.t. T_ij is the number of points that are below the segment (i, j) in the vertical stripe of the plane .
                In order to compute the number of points contained in some triangle formed by points x, y, z using this table, we compute T_xy + T_yz - T_xz. (TODO schema with numbers, explain "there are ... points below edge ..., ...")
                using table R</par>
                We call those constant-time operation Blue(a, b, c) and Red(a, b, c).
                Remember that points in our sets come in two : we separate . in the following, operations will be performed in constant time, and points will be accessible in radial ordering with regards to any reference point of S through .
                
            </div>
        </div>
        <div id="definitions" class="sectionDiv">
            Before going, we will first go over the key notions upon which the algorithm is built.
            <h2>Blue island</h2>
            A blue island is an island that contains only blue points.
            <h2>Anchor</h2>
            In order to find the actual largest blue island, we will iterate through all blue points of S, seeing those points as candidate uppermost points : that is, we will . eventually returning the largest one ever encountered through those n iterations. This uppermost most point will be refered to as "anchor" ; we say that an island, convex hull, or triangle is "anchored at p" if p is the uppermost point of this set.
            <h2>"Ending" in an edge</h2>
            Let us consider the convex hull's extreme points of an island I in S. Those points can be ordered as p_1, u_2, ..., p_k counter-clockwise, starting from the anchor p_1. In this case, we say that I "ends with" the edge (p_k-2, p_k-1). Note that this is not the very last, but rather the second to last edge of this polygon if we start from (p_1, p2) (then comes the edge (p_k-1, p_1)). For the sake of simplicity, we will now call those extreme edges "edges of the island".
            <h2>Edge weight</h2>
            Let us now think in reverse, and consider, for a given edge e and an anchor p, the largest blue island ending with e. It follows naturally that the edge with the highest weight is the second to last edge of the island we are looking for (which is not necessarily the largest blue island of S, but it is the largest blue island anchored at p). From this perspective, finding the largest blue island anchored at p is equivalent to finding the maximum weight edge, and trace back somehow to the previous edges
             and then the next one in clockwise order, ...etc. If you are starting to see some recurrence come on the horizon, that is spot on, but let us first define a notion that will coming handy for glueing edges together.
            <h2>p-compatibility</h2>
            Two edges a and b of a convex polygon anchored at p are said p-compatible if the two triangles they respectively form when connected to p are disjoint, and combine into a convex quadrilateral. Consequently, two disjoint islands anchored at p can be combined into one larger island if an edge of one is p-compatible with an edge of the other.
        </div>
        <div id="mainAlgorithm" class="sectionDiv">
        Now that the tedious sub-problems have been dealt with, the core of the algorithm is fairly simple to understand. We focus here on a single iteration over some anchor, looking to find the largest island under this point ; the complete algorithm consists of iterating over anchors, storing and updating the largest island encountered at any time.
        Let us first retrieve the radially sorted sequence of all points below an anchor that we call p, applying our previously defined half-cut operation on p and its corresponding line in R, with the cut vector -1_y. We name the points of the resulting filtered sequence p_1, p_2, ... p_k.
        We now consider all edges (p_i, p_j), i < j. We can view them as edges oriented counter-clockwise around p that form a graph among blue points under p, from which we can evict all non-viable edges : that is, edges (a, b) such that Red(p, a, b) > 0 (this is checked in constant time thanks to our structure T). We now want to compute the weights of all remaining edges : those will be stored in a matrix W, where W_ij is the weight of edge (p_i, p_j). Evicted edges are marked with a special value (for instance, -1), and the remaining ones are initialized with value 0.
        Aside from weights, we keep a data structure prev such that prev_ij contains the edge that precedes (p_i, p_j), or null otherwise.
        The first weights that we can compute easily are those of all edges coming from p_1 : in fact, islands that end with those edges cannot have other edges, so we set W_1,j to Blue(a, b, c) + 3 (since the Blue operation does not consider the extreme points of the triangle).
        The remaining points p_2, ..., p_k-1 now have both incoming and outgoing (with regards to their counter-clockwise orientation) edges : we will thus call them "pivots". The following recurrence relationships appears :
        For 1 <= i < k, if all predecessors p_j with 0 <= j < i have all their 
        This relationship enables dynamic programming : .
        One question remains : how to compute all outgoing edges of each pivots in linear time, in order to fall under the O(n^3) global time complexity; 
        Notice that this hypothesis holds for p_2, and will hold for p_3 if we compute the weight of all p_2's outgoing edges.
        </div>
        <div id="animation" class="sectionDiv">

        </div>
        <div id="multiplicity" class="sectionDiv">

        </div>
        <div id="generalization" class="sectionDiv">
            
        </div>
    </div>
    <script src="nav.js"></script>
  </body>
</html>
